@ngdoc overview
@name HTML & CSS Guidelines
@sortOrder 200
@description

# HTML and CSS

At Lithium, our goal when coding is that it be well-written, clean, and understandable. In short, code that can be easily read, worked on, and looks cohesive - as if one developer had written it. That is why when writing HTML and CSS, Lithium emulates widely-accepted best practices such as those outlined in [Google HTML/CSS Style Guide](http://google-styleguide.googlecode.com/svn/trunk/htmlcssguide.xml), [Idiomatic HTML](https://github.com/necolas/idiomatic-html) and [Idiomatic CSS](https://github.com/necolas/idiomatic-css). However, since our product is meant to be customized, some of these standard practices do not always work for us. This document is meant to highlight the divergences and establish the best practices that Lithium uses. To understand this document correctly, we recommend familiarizing yourself with [Google HTML/CSS Style Guide](http://google-styleguide.googlecode.com/svn/trunk/htmlcssguide.xml) and optionally [Idiomatic HTML](https://github.com/necolas/idiomatic-html) and [Idiomatic CSS](https://github.com/necolas/idiomatic-css).

HTML + CSS are fundamental aspects of the Lithium application's user experience.

## frameworks
We use a couple of frameworks that impact our HTML and CSS:

### twitter bootstrap
Lithium is taking an "all in" approach with [Twitter Bootstrap](http://getbootstrap.com/), which is a front-end framework to aid faster web development. The framework contains its own grid system as well as many standard, already styled elements. See their extensive documentation: [Bootstrap 3 Docs](http://getbootstrap.com/css). While there are many features of Twitter Bootstrap to capitalize on, there are also times where you must manipulate and extend the existing Twitter Bootstrap classes.

### angular.js
[AngularJS](http://angularjs.org/) is a JavaScript-based MV* framework. It is unique to most JavaScript frameworks in that it is not written solely inside of JavaScript, which would then use templates to generate the UI. Instead, it binds directives to existing DOM elements as well as allowing you to create custom tags by creating your directives.

## indentation, line breaks and whitespace
<div class="alert alert-info"> In general, we leave the customer's CSS formatting alone and place it above the Lithium CSS with a comment separator. </div>When editing customer header and footer CSS, match the customer's CSS formatting for consistency and legibility. Otherwise, use the rules below.

* New lines should be indented 2 spaces (not tabs).
* Don't add unnecessary empty lines to `.tpl`, `.js`, or `.scss` files.
* It is okay to add an extra line break between two methods for example, but only add line breaks where needed.
* As is widely seen and accepted, CSS declarations should follow a rule set's opening brace { on a new line, indented 2 spaces from the beginning of the containing rule set. We do not use the single line variation.

<strong>Correct CSS Indentation</strong>

```CSS
#li-body {
  background-color: red;
}

#li-body {
  .li-avatar {
    background-color: red;
  }
}

#li-body {
  background-color: red;
  color: white;
}
```

HTML declarations should likewise be indented with 2 spaces, with a distinct element requiring a new line and indent. If the element is a child element, its indent should match the parent's indent plus 2 additional spaces.

<strong>Correct HTML Indentation</strong>

```HTML
<div class="li-post">
    <a href="path/to/somewhere">
        <img src="path/to/image.png" alt="">
    </a>
    <p>[post text]</p>
    <button disabled>Reply</button>
</div>
```

## html
Every HTML element that has some purpose should have a <strong>unique</strong> CSS class. <strong>All CSS classes</strong> should begin with the prefix `li-`, the only exception for now being the re-use Twitter Bootstrap CSS class names to denote common elements. When in doubt, play it safe and add a unique CSS class. Because our product was meant to be customized and also needs to integrate as seamlessly as possible with customer code, it is very important that we follow this rule. It will help ensure that we do not duplicate our customer's class names and also give us hooks to use when customizing. To further ensure these hooks are good, be as descriptive as possible when naming classes and avoid using abbreviations. Hooks should preferably be classes and not IDs. While we are big into using classes, we avoid using IDs on element, unless it is needed as a javascript selector - exception: our `li-body`, which we use to namespace our code.

Groups: If you need to style or select each element in a group, give them all the same CSS class. If however, any of those elements in the group need individual styling or selection, sub-classing (adding another class) is necessary. For example, an unordered list of icons may all have the class `li-icon`. However, each icon has a different CSS background-image, resulting in a subclass like `li-icon li-icon-camera`. If you find that you need to wrap these in a container such as a `div`, `ul`, `ol` etc., consider using the suffix `-wrapper`.

## html and svg
In our mobile web application, we have chosen to implement all icons as inline svg tags. The reason inline svgs are perfect for our needs goes back to customization. Our customers will have a ready-to-use icon set that is resolution-independent (thus looking great on any mobile device) and they will have the ability to scale and re-color our icon set easily, through css. SVGs are also quite small in size, making them quicker to render even under less-than-great signal conditions. Lastly, having them inline removes another http request the site would have to make.

In order to keep our code clean, we have used a `<span ng-include=""></span>` which includes external SVG files into the document. The class on this span should indicate that it is an icon. The rules for putting classes on the span tag follow the normal guidelines.

<strong>Takeaways</strong>:

* All CSS classes should be prefixed with `li-`, with exceptions for the re-use of Twitter Bootstrap CSS class names.
* All purposeful HTML elements should be given unique CSS class names.
* Use descriptive, non-abbreviated CSS class names for elements.

## css
In an effort to avoid conflict and clashes with customer code, at Lithium we namespace all CSS. All CSS stylesheets should be namespaced within `#li-body`. Where possible, secondary namespacing with `.li-content` is advised. See the example of a detailed comment below.

For the same reason given for namespacing, it is also very important that no CSS is added to generic elements in the stylesheet such as `table`, `textarea`, `a`, `img`. If CSS needs to be added to these elements, add a properly prefixed CSS class to that element. There are exceptions to this. Because we are using Twitter Bootstrap to frame our markup and CSS, there will be times during customization when we will need to override their styles because they do use element tags within their stylesheets (<em>please read the Twitter Bootstrap Variables section below</em>). These are the only exceptions, however.

As a general rule to follow, <strong>don't use</strong> `!important`. Adding the `!important` declaration to a rule makes CSS more difficult to debug, since it effectively removes the "cascading" aspect from CSS. If you have a compelling (read: major) reason to use the `!important` declaration on a rule, make sure you've commented your code well to explain why it's there, for the benefit of other developers.

On the same note, <strong>don't use</strong> `*` The universal selector `*` matches any element. Google suggests not using the universal selector as a CSS "key" (the rightmost selector of a rule), but avoiding it as a general rule helps selector matching performance and can make debugging easier.

When writing your CSS attributes, properties should be alphabetized. Alphabetizing your attributes greatly helps readability when scanning, especially in a large project such as ours. <em>"All CSS attribute properties are alphabetized so that background is listed before color which is listed before display which is listed before margin which is listed before padding, and so on."</em>

<strong>Example of a detailed comment for `!important`</strong>

```CSS
#li-body {
  .li-content {
    .li-avatar {
      background-color: white;
      color: red !important; /* Workaround for a known IE-specific bug (see LIA-34 for more information) */
      text-transform: uppercase;
    }
  }
}
```

## css and svg
In mobile stylesheets, svg and its potential children elements (`path`, `rect`, `circle` etc) appear in the CSS. While they are exceptions the the no-elements rule, they should always be namespaced in the unique identifier given to its parent `span` tag.

<strong>Takeaways</strong>:

* All CSS stylesheets should be namespaced within `#li-body`.
* Avoid using `!important`
* Do not style generic elements (`table`, `img`, etc)*. Add a CSS class instead and style that class.
* Avoid using IDs, except as a JavaScript selector.
* Avoid the universal selector `*`
* CSS attribute properties should be in alphabetical order

## twitter bootstrap variables
One of the our favorite features of Twitter Bootstrap is its organizational capabilities. A big example of that is their variables file, which includes variable that control many facets of the layout, such as background and button color, padding and margins for the row and columns and more. Check this their own css and this file first to see if they have already made the property you want to change into a variable. We do not want to touch their variables and have designated the files named `skin.properties.scss` and `skin.properties.mobile.scss` (for desktop and mobile respectively) to handle these.

### sass
Lithium uses [Sass](http://sass-lang.com/) for CSS pre-processing. Sass allows you to write standard CSS, but with the addition of several nice features that we have taken advantage of. Sass files (ending in `.scss`) must be evaluated and transformed into valid CSS before being loaded by a web browser. First, wherever possible, use Sass nesting. Things are easier to find when properly nested and more specific. However, use common sense. CSS should probably be at least three levels deep (taking into account namespacing), but rarely more than five. Since our work is meant to be customized, this is very important the we create specificity so we don't create clashes with customer CSS and even our own.

<strong>Example of nesting:</strong>

<strong>OK:</strong>

```CSS
#li-body {
  .li-header {
  }
}
```

<strong>Better:</strong>

```CSS
#li-body {
  .li-content {
    .li-boards-list {
      .li-header {
      }
    }
  }
}
```

Another important feature of Sass is chaining. Chaining uses the `&` to preface pseudo selectors `&:hover` and other combination classes (referring to when an element has multiple class names).

<strong>Example</strong>

```CSS
#li-body {
  .li-content {
    .li-boards-list {
      .li-link {
	      color: white;
	      &:hover {
          color: red;
        }
      }
    }
  }
}
```

Sass uses a very handy feature: <strong>variables</strong>. This relates to a previous system we used, skin properties. These skin properties were a collection of values that were to be applied to an element through the CSS. As you can guess, we've translated these skin properties into variables. Skin properties live in our `angular-li-skins` repo. As a general rule, you should not have to create any color, spacing, padding, font-size or line-height values. These things are located in skin.properties and are included in every repository. There may also be other values in skin.properties and it can be added to on an as-needed basis.

<strong>Takeaways</strong>:

* Use Sass nesting and chaining.
* Use skin properties for things like colors, spacing, padding, font-size and line-height values.

## twitter bootstrap mixins

Twitter Bootstrap takes their commonly included styles that apply to certain classes or elements and gather them in one file to form the concept of mixins. As you might have already guessed, we take full advantage of this and put some of our frequently used styles in a file called li-mixins.mobile.scss. Mixins are dynamic functions that take in one or more values to create a snippet of commonly used CSS so that you do not have to copy and paste the same code multiple times.
A great example of this is Community Mobile V2's li-icon-wrapper mixin. The li-icon-wrapper class is added to the span that wraps every inline SVG icon. The mixin looks like this:
```CSS
@mixin li-icon-wrapper($size, $color) {
  @include li-icon-size($size);
  display: inline-block;
  position: relative;

  svg {
    @include li-icon-size($size);
    color: $color;
    left: 0;
    position: absolute;
    top: 0;

    //Target child elements to share fill color with parent SVG
    circle,
    ellipse,
    line,
    path,
    polygon,
    rect {
      fill: currentColor;
      stroke: transparent;
    }
  }
}
```

This mixin example illustrates several concepts:
* `@include`  is used and is how any mixin should be called, whether in code or in another mixin
* Mixins can affect even child classes
In this case the child classes of `SVG` and in turn child elements within them (such as `circle`) are given properties we want to have on every instance of `li-icon-wrapper`.  Since Communiyt Mobile v2 contains a lot of icons, you can imagine how much time this saved us.  Now, if we had wanted to change the display on every icon (with class `li-icon-wrapper`) from inline-block, it would essentially be a one line change to affect all of them. Additionally, if any one off styles are needed to modify this, simply declare them after your `@include`.
___
